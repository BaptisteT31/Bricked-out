<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Out - Jeu Responsive avec Secret</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      background-color: #f0f0f0;
      position: relative;
      font-family: sans-serif;
    }
    /* La balle */
    #ball {
      position: absolute;
      border-radius: 50%;
      background-image: url('texture.png'); /* Image locale */
      background-size: cover;
      z-index: 7;
    }
    /* Le paddle */
    #paddle {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 255, 0.5);
      z-index: 8;
    }
    /* Container des bricks */
    #blocks-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 35%; /* Hauteur réservée aux bricks */
      z-index: 5;
    }
    /* Les bricks */
    .block {
      position: absolute;
      background-color: #0095DD;
      border: 1px solid white;
      box-sizing: border-box;
      z-index: 6;
    }
    /* Les caractères secrets */
    .secret-letter {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      z-index: 4;
      /* Couleur initiale (par exemple gris) */
      color: gray;
    }
    /* Écran de démarrage, défaite et victoire (même container) */
    #start-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 10;
    }
    #start-screen p, #game-over p {
      font-size: 2em;
      margin: 0.5em;
    }
    #start-screen button, #game-over button {
      font-size: 1.5em;
      padding: 10px 20px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Balle et paddle -->
  <div id="ball"></div>
  <div id="paddle"></div>
  
  <!-- Container des bricks -->
  <div id="blocks-container"></div>
  
  <!-- Écran de démarrage / victoire / défaite -->
  <div id="start-screen">
    <p>Bienvenue ! Appuyez sur ▶ Jouer pour commencer.</p>
    <button id="play-btn">▶ Jouer</button>
  </div>
  <div id="game-over" style="display:none;">
    <p id="game-over-message"></p>
    <button id="restart-btn">Recommencer</button>
  </div>

  <script>
    // Configuration centralisée
    const config = {
      ballSize: 50,                   // Taille de la balle (en pixels)
      ballInitialSpeed: 3,            // Vitesse initiale de la balle
      paddleWidth: 100,               // Largeur du paddle
      paddleHeight: 10,               // Hauteur du paddle
      ballSpawnVerticalRatio: 0.33,   // La balle apparaît dans le tiers supérieur
      paddleVerticalPositionRatio: 0.66, // Le paddle se place à 66% de la hauteur
      extraSpeedFactor: 0.2,          // Influence de la vitesse horizontale du paddle sur la balle
      bounceAngleMax: Math.PI / 3,    // Angle maximum de rebond (60°)
      speedIncreaseFactor: 0.05,      // Augmentation de la vitesse de la balle au rebond sur le plafond
      // Configuration des bricks
      blockRows: 5,                   // Nombre de lignes de bricks
      blockCols: 8,                   // Nombre de colonnes de bricks
      blockWidth: 100,                // Largeur d'une brick
      blockHeight: 30,                // Hauteur d'une brick
      blockGap: 5,                    // Espace entre les bricks
      secretText: "A1B2"              // Texte secret composé de 4 caractères
    };

    // Variables globales pour les secrets
    let secretFound = 0;              // Nombre de secrets trouvés
    const secretTotal = config.secretText.length; // Doit être 4
    // Tableaux pour associer chaque secret à son élément
    let secretElements = [];         

    // Fonction pour adapter les dimensions en fonction de l'écran (responsive)
    function setResponsiveConfig() {
      const isMobile = window.innerWidth < 600;
      config.ballSize = isMobile ? window.innerWidth * 0.1 : 50;
      config.paddleWidth = isMobile ? window.innerWidth * 0.2 : 100;
      config.paddleHeight = isMobile ? window.innerWidth * 0.02 : 10;
      config.blockWidth = isMobile ? window.innerWidth * 0.12 : 100;
      config.blockHeight = isMobile ? window.innerWidth * 0.04 : 30;
      config.blockGap = isMobile ? 3 : 5;
    }
    setResponsiveConfig();

    const ball = document.getElementById('ball');
    const paddle = document.getElementById('paddle');
    const blocksContainer = document.getElementById('blocks-container');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const playBtn = document.getElementById('play-btn');
    const restartBtn = document.getElementById('restart-btn');
    const gameOverMessage = document.getElementById('game-over-message');

    // Appliquer les dimensions de la balle et du paddle
    ball.style.width = config.ballSize + 'px';
    ball.style.height = config.ballSize + 'px';
    paddle.style.width = config.paddleWidth + 'px';
    paddle.style.height = config.paddleHeight + 'px';

    let posX, posY, velocityX, velocityY;
    const ballRadius = config.ballSize / 2;
    let score = 0;  // Nombre de bricks détruits

    // Variables pour suivre la vitesse horizontale du paddle
    let lastMouseX = window.innerWidth / 2;
    let paddleSpeed = 0;
    let gameRunning = false;

    // Crée la grille de bricks et positionne les lettres secrètes sur 4 bricks aléatoires
    function createBlocks() {
      blocksContainer.innerHTML = "";
      secretElements = [];
      secretFound = 0;
      let blocksData = [];
      let brickIndex = 0;
      // Calcul pour centrer la grille
      const totalWidth = config.blockCols * config.blockWidth + (config.blockCols - 1) * config.blockGap;
      const offsetX = (window.innerWidth - totalWidth) / 2;
      const offsetY = 20; // marge depuis le haut
      // Création des bricks et stockage de leurs données
      for (let row = 0; row < config.blockRows; row++) {
        for (let col = 0; col < config.blockCols; col++) {
          const block = document.createElement('div');
          block.className = "block";
          const left = offsetX + col * (config.blockWidth + config.blockGap);
          const top = offsetY + row * (config.blockHeight + config.blockGap);
          block.style.width = config.blockWidth + "px";
          block.style.height = config.blockHeight + "px";
          block.style.left = left + "px";
          block.style.top = top + "px";
          // Attribuer un index à chaque brick
          block.setAttribute('data-index', brickIndex);
          blocksContainer.appendChild(block);
          blocksData.push({element: block, left: left, top: top, index: brickIndex});
          brickIndex++;
        }
      }
      // Sélectionner aléatoirement 4 indices distincts parmi les bricks
      let secretIndices = [];
      while (secretIndices.length < secretTotal && secretIndices.length < blocksData.length) {
        let randIndex = Math.floor(Math.random() * blocksData.length);
        if (!secretIndices.includes(randIndex)) {
          secretIndices.push(randIndex);
        }
      }
      // Pour chaque brick sélectionnée, marquer la brick et créer l'élément secret
      for (let i = 0; i < secretIndices.length; i++) {
        const data = blocksData[secretIndices[i]];
        // Marquer la brick avec l'ordre secret (0 à 3)
        data.element.setAttribute('data-secret', i);
        // Créer l'élément secret-letter associé
        const letter = document.createElement('div');
        letter.className = "secret-letter";
        letter.textContent = config.secretText[i];
        letter.style.left = data.left + "px";
        letter.style.top = data.top + "px";
        letter.style.width = config.blockWidth + "px";
        letter.style.height = config.blockHeight + "px";
        // Initialement, la couleur est gris (déjà défini dans CSS) ; elle passera en noir quand découvert
        letter.setAttribute('data-secret-order', i);
        blocksContainer.appendChild(letter);
        secretElements.push(letter);
      }
    }

    // Réinitialise ou initialise la position de la balle
    function resetBall() {
      posX = Math.random() * (window.innerWidth - config.ballSize);
      posY = Math.random() * ((window.innerHeight * config.ballSpawnVerticalRatio) - config.ballSize);
      velocityX = config.ballInitialSpeed;
      velocityY = config.ballInitialSpeed;
    }

    // Positionne le paddle en fonction de la position X et selon la config pour Y
    function updatePaddlePosition(x) {
      paddle.style.left = x + 'px';
      paddle.style.top = (window.innerHeight * config.paddleVerticalPositionRatio) + 'px';
    }

    // Détecte la collision entre la balle (cercle) et un élément rectangulaire
    function checkCollision(element) {
      const ballCenterX = posX + ballRadius;
      const ballCenterY = posY + ballRadius;
      const rect = element.getBoundingClientRect();
      const closestX = Math.max(rect.left, Math.min(ballCenterX, rect.right));
      const closestY = Math.max(rect.top, Math.min(ballCenterY, rect.bottom));
      const distanceX = ballCenterX - closestX;
      const distanceY = ballCenterY - closestY;
      return (distanceX * distanceX + distanceY * distanceY) < (ballRadius * ballRadius);
    }

    // Fonction de victoire
    function victory() {
      gameRunning = false;
      gameOverMessage.textContent = "Victoire ! Le code est : " + config.secretText;
      gameOverScreen.style.display = 'flex';
    }

    // Fonction de fin de partie (défaite)
    function gameOver() {
      gameRunning = false;
      gameOverMessage.textContent = "Perdu ! Fais un effort 👉\nScore : " + score + " bricks détruits";
      gameOverScreen.style.display = 'flex';
    }

    // Fonction pour démarrer le jeu
    function startGame() {
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      setResponsiveConfig();
      ball.style.width = config.ballSize + 'px';
      ball.style.height = config.ballSize + 'px';
      paddle.style.width = config.paddleWidth + 'px';
      paddle.style.height = config.paddleHeight + 'px';
      score = 0;
      createBlocks();
      resetBall();
      lastMouseX = window.innerWidth / 2;
      updatePaddlePosition(window.innerWidth / 2);
      gameRunning = true;
      updatePosition();
    }

    // Fonction principale de l'animation
    function updatePosition() {
      if (!gameRunning) return;
      
      let nextPosX = posX + velocityX;
      let nextPosY = posY + velocityY;

      // Rebonds sur les parois latérales
      if (nextPosX <= 0) {
        nextPosX = 0;
        velocityX = -velocityX;
      } else if (nextPosX + config.ballSize >= window.innerWidth) {
        nextPosX = window.innerWidth - config.ballSize;
        velocityX = -velocityX;
      }

      // Rebonds sur le plafond
      if (nextPosY <= 0) {
        nextPosY = 0;
        velocityY = -velocityY;
        velocityX *= (1 + config.speedIncreaseFactor);
        velocityY *= (1 + config.speedIncreaseFactor);
      }

      // Vérification du sol (défaite)
      if (nextPosY + config.ballSize >= window.innerHeight) {
        gameOver();
        return;
      }

      posX = nextPosX;
      posY = nextPosY;

      // Collision avec le paddle (uniquement si la balle descend)
      if (velocityY > 0 && checkCollision(paddle)) {
        const paddleRect = paddle.getBoundingClientRect();
        const paddleCenterX = paddleRect.left + paddleRect.width / 2;
        const ballCenterX = posX + ballRadius;
        let hitFactor = (ballCenterX - paddleCenterX) / (paddleRect.width / 2);
        hitFactor = Math.max(-1, Math.min(1, hitFactor));
        const bounceAngle = hitFactor * config.bounceAngleMax;
        const currentSpeed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
        const extraSpeed = Math.abs(paddleSpeed) * config.extraSpeedFactor;
        const newSpeed = currentSpeed + extraSpeed;
        velocityX = newSpeed * Math.sin(bounceAngle);
        velocityY = -Math.abs(newSpeed * Math.cos(bounceAngle));
        posY = paddleRect.top - config.ballSize;
      }

      // Collision avec les bricks
      const bricks = document.getElementsByClassName("block");
      for (let i = bricks.length - 1; i >= 0; i--) {
        if (checkCollision(bricks[i])) {
          const brickRect = bricks[i].getBoundingClientRect();
          const ballRect = {
            left: posX,
            top: posY,
            right: posX + config.ballSize,
            bottom: posY + config.ballSize
          };
          const overlapX = Math.min(ballRect.right - brickRect.left, brickRect.right - ballRect.left);
          const overlapY = Math.min(ballRect.bottom - brickRect.top, brickRect.bottom - ballRect.top);
          if (overlapX < overlapY) {
            velocityX = -velocityX;
          } else {
            velocityY = -velocityY;
          }
          // Vérifier si cette brick était "secret"
          if (bricks[i].hasAttribute("data-secret")) {
            const secretOrder = bricks[i].getAttribute("data-secret");
            // Rechercher l'élément secret correspondant et changer sa couleur en noir
            secretElements.forEach(el => {
              if (el.getAttribute("data-secret-order") === secretOrder) {
                el.style.color = "black";
              }
            });
            secretFound++;
            // Si tous les secrets ont été révélés, déclencher la victoire
            if (secretFound === secretTotal) {
              victory();
              return;
            }
          }
          bricks[i].parentNode.removeChild(bricks[i]);
          score++;
          // Traiter une collision par frame
          break;
        }
      }

      ball.style.left = posX + 'px';
      ball.style.top = posY + 'px';

      requestAnimationFrame(updatePosition);
    }

    // Suivi du mouvement de la souris pour déplacer le paddle
    document.addEventListener('mousemove', (e) => {
      updatePaddlePosition(e.clientX);
      paddleSpeed = e.clientX - lastMouseX;
      lastMouseX = e.clientX;
    });

    // Écouteur pour le tactile sur mobile
    document.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      updatePaddlePosition(touch.clientX);
      paddleSpeed = touch.clientX - lastMouseX;
      lastMouseX = touch.clientX;
    }, { passive: false });

    playBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);

    // Affichage initial
    ball.style.left = '0px';
    ball.style.top = '0px';
    updatePaddlePosition(window.innerWidth / 2);
    startScreen.style.display = 'flex';
    gameOverScreen.style.display = 'none';
  </script>
</body>
</html>
